By default pytest captures standard-output while running tests. Only if a test fails, the captured output is shown.

Meaning, if the test is a pass, the print stmts are not logged to console.

We can use -s option, toprint to stdout or to console in all cases.

pytest options:

--lf - last failed , run only last failed tests.
--ff - failed first, run failed tests first.
-v - for verbose output.
pytest --cache-show - to see the cache.
--stepwise - the test will run untill the first failure and then it stops.

python3 -m pytest -s ./tests/test_module01.py -k "test_a1 or test_a3" , to run two specific tests

this if for tagging the tests
@pytest.mark.marked
def test_a3():
    assert 10-5==5

To execute the specific tagged test use:
python3 -m pytest -s ./tests/test_module01.py -m marked

conftest.py - special file from where config can be set
pytest_addoption - function to add options
pytest_config - to get the config

python3 -m pytest -s ./tests/test_module01.py -m "marked and not str"

module level marking :
pytestmark = [ pytest.mark.marked, pytest.mark.str ]

xfail = expected failure

You use it when you know a test will fail, e.g., because a bug hasn’t been fixed yet.

Pytest will not mark the test as failed, it will report it as "expected failure."

This is useful in CI/CD pipelines so your suite doesn’t fail for known issues.
When you run this test:

If the assertion fails → pytest reports xfail (expected) ✅

If the assertion passes → pytest reports xpass (unexpected pass) ⚠️

@pytest.mark.parametrize("a,b",[(1,4),(2,1),(3,7),(4,5)])
def test_param02(a,b):
    assert a<b

suppose there is a config file with all the variables for the setup and you want to use them in the test case
then either use a fixture in conftest.py and return the varibales in a dictionary format.
or save the variables in a dictionary file in pytest.data={}.
this pytest.data can be used in the test cases.

conftest.py is automatically discovered by pytest.

import pytest

def load_config(path="config.txt"):
    config = {}
    with open(path) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            key, value = line.split("=", 1)
            config[key] = value
    return config


@pytest.fixture(scope="session")
def config():
    return load_config()


use it in tests:
def test_login(config):
    assert config["username"] == "admin"
    assert int(config["timeout"]) > 10

as a varaible in pytest:
conftest.py

def pytest_configure():
    pytest.config_data = {}
    with open("config.txt") as f:
        for line in f:
            if "=" in line:
                key, value = line.strip().split("=", 1)
                pytest.config_data[key] = value


import pytest

def test_something():
    assert pytest.config_data["base_url"].startswith("https")